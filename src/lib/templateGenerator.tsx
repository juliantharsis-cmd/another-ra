/**
 * Table Template Generator
 * 
 * Utility functions to help generate table configurations following the blueprint pattern.
 * Based on the user table implementation as the reference template.
 */

import React from 'react'
import { ListDetailTemplateConfig, ColumnConfig, FieldConfig, FilterConfig, PanelConfig, ApiClient } from '@/components/templates/types'
import { autoGenerateFilters, mergeFilters } from './autoGenerateFilters'

/**
 * Generate a basic table configuration following the blueprint pattern
 */
export function generateTableConfig<T extends { id: string }>(params: {
  entityName: string
  entityNamePlural: string
  description?: string
  fields: FieldConfig[]
  columns: ColumnConfig[]
  apiClient: ApiClient<T>
  defaultSortField?: string
  defaultSortOrder?: 'asc' | 'desc'
  pageSizeOptions?: number[]
  showImportExport?: boolean
  panelTitleKey?: string
  panelSections?: Array<{ id: string; title: string; fields: string[]; collapsible?: boolean }>
  manualFilters?: FilterConfig[]
  deleteConfirmMessage?: string
}): ListDetailTemplateConfig<T> {
  const {
    entityName,
    entityNamePlural,
    description,
    fields,
    columns,
    apiClient,
    defaultSortField,
    defaultSortOrder = 'asc',
    pageSizeOptions = [10, 25, 50, 100],
    showImportExport = true,
    panelTitleKey,
    panelSections = [],
    manualFilters = [],
    deleteConfirmMessage,
  } = params

  // Auto-generate filters (may return empty array if no filterable fields exist)
  // This is expected behavior - text/textarea fields use global search instead
  const autoGeneratedFilters = autoGenerateFilters(fields, apiClient, manualFilters || [])
  const allFilters = mergeFilters(manualFilters || [], autoGeneratedFilters || [])
  
  // Ensure filters is always an array (even if empty)
  // Empty filters array is valid - it just means no filters will be displayed

  // Default panel sections if not provided
  const defaultSections = panelSections.length > 0 
    ? panelSections 
    : fields.reduce((acc, field) => {
        const sectionId = field.section || 'general'
        const existingSection = acc.find(s => s.id === sectionId)
        
        if (existingSection) {
          existingSection.fields.push(field.key)
        } else {
          acc.push({
            id: sectionId,
            title: sectionId.charAt(0).toUpperCase() + sectionId.slice(1),
            fields: [field.key],
            collapsible: sectionId !== 'general',
          })
        }
        
        return acc
      }, [] as Array<{ id: string; title: string; fields: string[]; collapsible?: boolean }>)

  // Determine panel title key
  const titleKey = panelTitleKey || fields.find(f => f.required)?.key || fields[0]?.key || 'id'

  // Build configuration
  // Note: filters can be an empty array if no filterable fields exist (e.g., only text/textarea fields)
  // This is expected and handled gracefully by ListDetailTemplate
  const config: ListDetailTemplateConfig<T> = {
    entityName,
    entityNamePlural,
    description,
    columns,
    fields,
    filters: allFilters || [], // Ensure filters is always an array
    panel: {
      titleKey,
      sections: defaultSections.map(section => ({
        id: section.id,
        title: section.title,
        fields: section.fields,
        collapsible: section.collapsible ?? section.id !== 'general',
      })),
      actions: deleteConfirmMessage ? {
        delete: {
          label: 'Delete',
          confirmMessage: deleteConfirmMessage,
        },
      } : undefined,
    },
    apiClient,
    defaultSort: defaultSortField ? {
      field: defaultSortField,
      order: defaultSortOrder,
    } : undefined,
    pageSizeOptions,
    showImportExport,
  }

  return config
}

/**
 * Generate a linked record field configuration
 */
export function generateLinkedRecordField(params: {
  key: string
  label: string
  apiEndpoint: string
  nameField?: string
  idField?: string
  section?: string
  searchable?: boolean
  initialLimit?: number
}): FieldConfig {
  const {
    key,
    label,
    apiEndpoint,
    nameField = 'name',
    idField = 'id',
    section = 'relationships',
    searchable = true,
    initialLimit = 50,
  } = params

  return {
    key,
    label,
    type: 'choiceList',
    editable: true,
    searchable,
    section,
    options: async (searchQuery?: string, signal?: AbortSignal) => {
      try {
        const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api'
        const queryParams = new URLSearchParams()
        queryParams.append('paginated', 'true')
        
        if (searchQuery && searchQuery.trim()) {
          queryParams.append('search', searchQuery.trim())
          queryParams.append('limit', '100')
        } else {
          queryParams.append('limit', String(initialLimit))
          queryParams.append('sortBy', nameField)
          queryParams.append('sortOrder', 'asc')
        }
        
        const abortSignal = signal || AbortSignal.timeout(10000)
        
        const response = await fetch(`${API_BASE_URL}/${apiEndpoint}?${queryParams.toString()}`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          signal: abortSignal,
        })
        
        if (response.ok) {
          const result = await response.json()
          if (result.success && result.data) {
            return result.data.map((item: any) => {
              const name = item[nameField] || item.id
              const id = item[idField] || item.id
              return `${name}|${id}`
            })
          }
        }
      } catch (err: any) {
        if (err.name === 'AbortError' || err.name === 'TimeoutError') {
          throw err
        }
        console.error(`Error fetching ${label}:`, err)
      }
      return []
    },
  }
}

/**
 * Generate a linked record column configuration with resolved names
 */
export function generateLinkedRecordColumn(params: {
  key: string
  resolvedKey: string
  label: string
  idField?: string
}): ColumnConfig {
  const {
    key,
    resolvedKey,
    label,
    idField = key,
  } = params

  return {
    key: resolvedKey, // Use resolved name field (e.g., 'CompanyName')
    label,
    sortable: false,
    filterable: false,
    align: 'left',
    render: (value: string | string[] | undefined, item: any) => {
      // Always use resolved names - never show IDs
      let namesArray: string[] = []
      
      if (value) {
        if (Array.isArray(value)) {
          namesArray = value.filter(Boolean).filter((n: string) => n && !n.startsWith('rec'))
        } else if (typeof value === 'string' && value !== '' && !value.startsWith('rec')) {
          namesArray = [value]
        }
      }
      
      // Check item directly if value is empty
      if (namesArray.length === 0 && item[resolvedKey]) {
        if (Array.isArray(item[resolvedKey])) {
          namesArray = item[resolvedKey].filter(Boolean).filter((n: string) => n && !n.startsWith('rec'))
        } else if (typeof item[resolvedKey] === 'string' && !item[resolvedKey].startsWith('rec')) {
          namesArray = [item[resolvedKey]]
        }
      }
      
      // Show loading state if IDs exist but names not resolved
      if (namesArray.length === 0) {
        const hasIds = item[idField] && (
          Array.isArray(item[idField]) 
            ? item[idField].length > 0 && item[idField].some((id: string) => id && id.startsWith('rec'))
            : typeof item[idField] === 'string' && item[idField].startsWith('rec')
        )
        
        if (hasIds) {
          return <span className="text-sm text-neutral-400 italic">Loading...</span>
        }
        
        return <span className="text-sm text-neutral-400">—</span>
      }
      
      // Display as green badges
      return (
        <div className="flex flex-wrap items-center gap-1.5">
          {namesArray.map((name, idx) => (
            <span
              key={idx}
              className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-700 border border-green-200"
            >
              {name}
            </span>
          ))}
        </div>
      )
    },
  }
}

/**
 * Generate a status/select column with color coding
 */
export function generateStatusColumn(params: {
  key: string
  label: string
  statusColors: Record<string, { bg: string; text: string }>
  defaultColor?: { bg: string; text: string }
  sortable?: boolean
  filterable?: boolean
  width?: string
}): ColumnConfig {
  const {
    key,
    label,
    statusColors,
    defaultColor = { bg: 'bg-neutral-100', text: 'text-neutral-800' },
    sortable = true,
    filterable = true,
    width = 'w-24',
  } = params

  return {
    key,
    label,
    sortable,
    filterable,
    align: 'center',
    width,
    render: (value: string) => {
      const colors = statusColors[value] || defaultColor
      return (
        <span className={`inline-flex px-2 py-1 text-xs font-medium rounded-full ${colors.bg} ${colors.text}`}>
          {value || '—'}
        </span>
      )
    },
  }
}

/**
 * Generate an attachment column with thumbnails
 */
export function generateAttachmentColumn(params: {
  key: string
  label: string
  maxThumbnails?: number
}): ColumnConfig {
  const {
    key,
    label,
    maxThumbnails = 3,
  } = params

  return {
    key,
    label,
    sortable: false,
    filterable: false,
    align: 'left',
    render: (value: any) => {
      if (!value) return <span className="text-sm text-neutral-400">—</span>
      
      const attachments = Array.isArray(value) ? value : [value]
      const validAttachments = attachments.filter((att: any) => att && att.url)
      
      if (validAttachments.length === 0) return <span className="text-sm text-neutral-400">—</span>
      
      const displayAttachments = validAttachments.slice(0, maxThumbnails)
      
      return (
        <div className="flex items-center gap-1.5">
          {displayAttachments.map((att: any, idx: number) => (
            <div key={idx} className="relative">
              <img
                src={att.thumbnails?.small?.url || att.url}
                alt={att.filename || 'Attachment'}
                className="w-8 h-8 object-cover rounded border border-neutral-200"
                onError={(e) => {
                  // Fallback to document icon
                  e.currentTarget.style.display = 'none'
                  const icon = e.currentTarget.nextElementSibling as HTMLElement
                  if (icon) icon.style.display = 'block'
                }}
              />
              <svg
                className="w-8 h-8 text-neutral-400 hidden"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
            </div>
          ))}
          {validAttachments.length > maxThumbnails && (
            <span className="text-xs text-neutral-500">+{validAttachments.length - maxThumbnails}</span>
          )}
        </div>
      )
    },
  }
}

