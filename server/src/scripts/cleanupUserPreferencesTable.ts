/**
 * Cleanup User Preferences Table
 * 
 * Removes old key-value preference fields that are no longer needed
 * after switching to direct 1:1 mapping approach.
 * 
 * Run with: npm run cleanup:user-preferences-table
 */

// Load environment variables
import dotenv from 'dotenv'
import { resolve } from 'path'
dotenv.config({ path: resolve(__dirname, '../../.env') })
dotenv.config() // Also try default location

const API_KEY = process.env.AIRTABLE_PERSONAL_ACCESS_TOKEN || process.env.AIRTABLE_API_KEY
const BASE_ID = process.env.AIRTABLE_SYSTEM_CONFIG_BASE_ID || 'appGtLbKhmNkkTLVL' // System configuration base
const TABLE_NAME = 'User Preferences'

if (!API_KEY) {
  console.error('‚ùå AIRTABLE_PERSONAL_ACCESS_TOKEN or AIRTABLE_API_KEY is required')
  console.error('   Please set it in your server/.env file')
  process.exit(1)
}

// Use native fetch (Node 18+) or try to import node-fetch
async function getFetchFn(): Promise<typeof fetch> {
  if (typeof globalThis.fetch !== 'undefined') {
    return globalThis.fetch
  }
  try {
    const { default: fetch } = await import('node-fetch')
    return fetch as any
  } catch {
    throw new Error('fetch is not available. Use Node.js 18+ or install node-fetch')
  }
}

/**
 * Fields to DELETE (old key-value preference system fields)
 */
const FIELDS_TO_DELETE = [
  'Namespace',
  'Key',
  'Table Id',
  'Scope Id',
  'Type',
  'Value (text)',
  'Value (number)',
  'Value (boolean)',
  'Visibility',
  'Expires At',
  'Unique Key',
  'Checksum',
]

/**
 * Fields to KEEP (direct mapping fields)
 */
const FIELDS_TO_KEEP = [
  'User Id',
  'Language',
  'Date Format',
  'Time Format',
  'Time Zone',
  'Theme',
  'Use Schneider Colors',
  'Email Notifications',
  'In App Alerts',
  'Default Page Size',
  'Default Sort Field',
  'Default Sort Order',
  'Created At', // Auto-generated by Airtable
  'Last Modified', // Auto-generated by Airtable
]

async function cleanupUserPreferencesTable() {
  try {
    const fetchFn = await getFetchFn()
    
    console.log('üßπ Cleaning up "User Preferences" table in Airtable...')
    console.log(`   Base ID: ${BASE_ID}`)
    console.log(`   Table Name: ${TABLE_NAME}\n`)

    // Step 1: Get table ID and existing fields
    console.log('üìã Step 1: Finding table and getting fields...')
    const listTablesUrl = `https://api.airtable.com/v0/meta/bases/${BASE_ID}/tables`
    const listResponse = await fetchFn(listTablesUrl, {
      headers: {
        Authorization: `Bearer ${API_KEY}`,
        'Content-Type': 'application/json',
      },
    })

    if (!listResponse.ok) {
      const errorText = await listResponse.text()
      throw new Error(`Failed to list tables: ${listResponse.status} ${errorText}`)
    }

    const tablesData = await listResponse.json() as { tables: Array<{ id: string; name: string; fields?: Array<{ id: string; name: string; type: string }> }> }
    const table = tablesData.tables.find(t => t.name === TABLE_NAME)

    if (!table) {
      throw new Error(`Table "${TABLE_NAME}" not found.`)
    }

    console.log(`   ‚úÖ Found table: ${TABLE_NAME} (ID: ${table.id})\n`)

    // Step 2: Identify fields to delete
    console.log('üìã Step 2: Identifying fields to delete...')
    
    if (!table.fields || table.fields.length === 0) {
      console.log('   ‚ö†Ô∏è  No fields found in table')
      return
    }

    const existingFieldNames = new Map<string, string>() // name -> id
    table.fields.forEach(f => {
      existingFieldNames.set(f.name, f.id)
    })

    const fieldsToDelete = FIELDS_TO_DELETE.filter(name => existingFieldNames.has(name))
    const fieldsToKeep = FIELDS_TO_KEEP.filter(name => existingFieldNames.has(name))
    const unknownFields = table.fields.filter(f => 
      !FIELDS_TO_DELETE.includes(f.name) && !FIELDS_TO_KEEP.includes(f.name)
    )

    console.log(`   Found ${table.fields.length} total field(s)`)
    console.log(`   Fields to keep: ${fieldsToKeep.length}`)
    console.log(`   Fields to delete: ${fieldsToDelete.length}`)
    if (unknownFields.length > 0) {
      console.log(`   ‚ö†Ô∏è  Unknown fields (will not delete): ${unknownFields.map(f => f.name).join(', ')}`)
    }
    console.log('')

    if (fieldsToDelete.length === 0) {
      console.log('   ‚úÖ No fields to delete. Table is already clean.\n')
      return
    }

    // Step 3: Confirm deletion
    console.log('üìã Step 3: Fields that will be deleted:')
    fieldsToDelete.forEach(name => {
      console.log(`   - ${name}`)
    })
    console.log('')
    console.log('‚ö†Ô∏è  WARNING: This will permanently delete these fields and all their data!')
    console.log('   Make sure you have a backup if needed.\n')

    // Step 4: Delete fields using Airtable SDK (more reliable)
    console.log('üìã Step 4: Deleting fields...')
    console.log('   ‚ö†Ô∏è  Note: Field deletion via Metadata API may require specific permissions.')
    console.log('   If deletion fails, you may need to delete fields manually in Airtable UI.\n')
    
    const tableId = table.id
    let deletedCount = 0
    let errorCount = 0
    let skippedCount = 0

    // Try using Airtable SDK for deletion
    try {
      const Airtable = require('airtable')
      Airtable.configure({ apiKey: API_KEY })
      const base = Airtable.base(BASE_ID)
      
      // Get the table to access fields
      const airtableTable = base(TABLE_NAME)
      
      // Note: Airtable SDK doesn't directly support field deletion
      // We'll use the Metadata API with proper field IDs
      for (const fieldName of fieldsToDelete) {
        const fieldId = existingFieldNames.get(fieldName)
        if (!fieldId) {
          console.log(`   ‚ö†Ô∏è  Field "${fieldName}" not found (skipping)`)
          skippedCount++
          continue
        }

        try {
          // Try the Metadata API DELETE endpoint
          const deleteFieldUrl = `https://api.airtable.com/v0/meta/bases/${BASE_ID}/tables/${tableId}/fields/${fieldId}`
          const deleteResponse = await fetchFn(deleteFieldUrl, {
            method: 'DELETE',
            headers: {
              Authorization: `Bearer ${API_KEY}`,
              'Content-Type': 'application/json',
            },
          })

          if (deleteResponse.ok) {
            console.log(`   ‚úÖ Deleted field: ${fieldName}`)
            deletedCount++
          } else {
            const errorText = await deleteResponse.text()
            const errorData = JSON.parse(errorText)
            
            // Check if it's a permission issue
            if (errorData.error?.type === 'NOT_FOUND' || errorData.error?.type === 'UNAUTHORIZED') {
              console.log(`   ‚ö†Ô∏è  Cannot delete "${fieldName}": ${errorData.error.message || 'Permission denied or field not found'}`)
              console.log(`      ‚Üí Please delete this field manually in Airtable UI`)
              skippedCount++
            } else {
              console.log(`   ‚ùå Failed to delete "${fieldName}": ${errorText}`)
              errorCount++
            }
          }
        } catch (error) {
          console.log(`   ‚ùå Error deleting "${fieldName}":`, error instanceof Error ? error.message : error)
          errorCount++
        }
      }
    } catch (sdkError) {
      console.log('   ‚ö†Ô∏è  Airtable SDK not available, using Metadata API only')
      // Fallback to Metadata API only (already attempted above)
    }

    console.log('')

    // Step 5: Summary
    console.log('üìã Step 5: Summary...')
    console.log('')
    if (deletedCount > 0) {
      console.log(`‚úÖ Successfully deleted ${deletedCount} field(s).`)
    }
    if (skippedCount > 0) {
      console.log(`‚ö†Ô∏è  ${skippedCount} field(s) need to be deleted manually in Airtable UI.`)
      console.log('   The Metadata API may not support field deletion, or your token lacks permissions.')
    }
    if (errorCount > 0) {
      console.log(`‚ùå ${errorCount} error(s) occurred during deletion.`)
    }
    if (deletedCount === 0 && skippedCount === 0 && errorCount === 0) {
      console.log('‚úÖ No fields needed deletion.')
    }
    console.log('')
    console.log('üìù Remaining fields:')
    const remainingFields = table.fields.filter(f => !fieldsToDelete.includes(f.name))
    remainingFields.forEach(f => {
      const status = FIELDS_TO_KEEP.includes(f.name) ? '‚úÖ' : '‚ö†Ô∏è'
      console.log(`   ${status} ${f.name} (${f.type})`)
    })
    console.log('')

  } catch (error) {
    console.error('‚ùå Error cleaning up table:', error)
    if (error instanceof Error) {
      console.error('   Message:', error.message)
    }
    process.exit(1)
  }
}

// Run the script
cleanupUserPreferencesTable()
  .then(() => {
    process.exit(0)
  })
  .catch((error) => {
    console.error('üí• Fatal error:', error)
    process.exit(1)
  })

